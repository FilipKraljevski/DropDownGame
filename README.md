# Drop Down Game
Оваа апликација т.е. игра е наречена Drop Down Game. Целта на играта е играчот, кој претставува мал квадрат, да се спушта надолу колку што 
е можно низ повеќе платформи кои се движат во спротивна насока односно нагоре. Играчот ќе може да се движи со помош на стрелките за лево 
и десно. Целта е тој да не излезе надвор од формата бидејќи тоа ќе се смета за крај на играта. Колку повеќе платформи изминуваат 
нагоре, надвор од формата, толку повеќе поени добива играчот. На секои 20 поени играта станува потешка. Првите 20 поени се зголемува 
паѓањето (гравитацијата) на играчот (што претставува квадрат), на следните 20(20+20=40) поени се зголемува брзината на движењето на играчот
лево и десно, па потоа на третите 20(40+20=60) поени се зголемува брзината на движењето на платформите нагоре. Потоа на четвртите 20 поени
пак се зголемува гравитацијата и така натака. Крајот на играта претставува кога играчот ќе стигне до 200 поени.
# Опис на решението
За реализирањето на оваа игра беа потребни 2 класи и 1 форма.
 
Класата Player.cs се чуваат податоци за играчот како PictureBox, гравитацијата, скорот, брзината на движење, дали се движи лево или десно.

Класата Scene.cs се чуваат податоци за играта како обејкт од класта Player, Panel, рандом променлива, променливи кои ја памтат претходната
гравитација и брзина, променлива за брзината на движење на платформите, променлива како индикатор за дали да се зголеми 
гравитацијата/брзината на играчот/брзината на платфромите, и индекс променлива која служи за коментари. Во оваа класа се извршува главната
функција void Move().

Класата Form1.cs е главната формата која се пркижува на екранот цело време додека играчот ја игра играта. Се чува објект од класата Scene, 
низа од стрингови што претставуваат коментари, и count променлива. Во оваа форма се повикуваат 4 евента, а тоа се void Form1_KeyDown(), 
void Form1_Keyup(), void gameTimer_Tick(), и void readyTimer_Tick().
# Опис на главната функција Move() во класaта Scene
```
public void Move()
        {
            Player.player.Top += Player.gravity;
            if (Player.moveLeft && Player.player.Left > 1)
            {
                Player.player.Left -= Player.speed;
            }
            if (Player.moveRight && Player.player.Left + Player.player.Width < Panel.Width)
            {
                Player.player.Left += Player.speed;
            }
            foreach (Control x in Panel.Controls)
            {
                if (x is PictureBox && x.Tag == "platform")
                {
                    x.Top -= PlatformsSpeed;
                    if (x.Top < Panel.Top - x.Height)
                    {
                        x.Top = Panel.Height + x.Height;
                        x.Width = Rnd.Next(100, 400);
                        Player.score++;
                        if (Player.score % 20 == 0)
                        {
                            if (GxSxPS == 1)
                            {
                                LastGravity += 2;
                            }
                            else if(GxSxPS == 2)
                            {
                                LastSpeed += 2;
                            }
                            else
                            {
                                PlatformsSpeed++;
                                GxSxPS = 0;
                            }
                            GxSxPS++;
                            I++;
                        }
                    }
                    if (Player.player.Bounds.IntersectsWith(x.Bounds))
                    {
                        Player.gravity = 0;
                        Player.player.Top = x.Top - Player.player.Height;
                    }
                    else
                    {
                        Player.gravity = LastGravity;
                        Player.speed = LastSpeed;
                    }
                }
            }
        }
```
На секој повик на методата се поместува топ позицијата на играчот со гравитацијата. Потоа се проверува дали е притиснато лево или десно
копче од тастатурата и дали тие не излегуваат надвор од панелот. Доколку е исполнет условот тогаш помести го играчот за лево или десно во 
однос на брзината на движење. Следно е циклус за платформите, топ позицијата на платформите се одзема со брзината на движење на 
платформите. Доколку платформата излезе надвор од панелот, се рекреира нова платформа со топ позиција која е еднаква на висината на панелот
плус висината на платформата, должината на платформата се добива со рандом променлива не помала од 100 и не поголема од 400 и скорот се
зголемува за 1. Потоа се проверува дали скорот е делив со 20, ако ова е точно, тогаш се зголемува или гравитацијата или брзината на движење
на играчот или брзината на движење на платформите, се зголеува и индексот за коментари. Со завршување на циклусот, се проверува дали
играчот и платформата се поклопуваат, ако е точно, гравитацијата се иницијализира на 0 и топ позицијата на играчот е еднаква на топ
позицијата на платформата минус висината на панелот. Во спротивно гравитацијата и брзината ги задржуваат претходните вредности.
# Screenshots
![ReadyDDG](https://user-images.githubusercontent.com/86956087/176487338-0d59bab8-f6c5-4dfa-9b5c-ee656037f47a.png)
